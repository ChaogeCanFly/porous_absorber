<!DOCTYPE html>
    <html>
      <head>
        <meta charset=utf-8 />
        <title>Connect plot points using Bezier curves</title>
      </head>
      <body>
        <canvas id="canvas"></canvas>
        <style>
          html { position: relative; height: 100%; width: 100%; }
          body { position: absolute; left: 0; right: 0; top: 0; bottom: 0; } 
          canvas { outline: 1px solid red; }
        </style>
        <script>
          const TWO_PI       = 2.0 * Math.PI
          const POINT_RADIUS = 5.0
          const TENSION      = 0.45

          // Array of mouse click coordinates
          var points=[]

          // DOM Access utility function
          function $(id) {
            return document.getElementById(id)
          }

          window.onload = window.onresize = () => {
            let canvas = $("canvas")
            canvas.width  = parseInt(window.getComputedStyle(document.body).width)
            canvas.height = parseInt(window.getComputedStyle(document.body).height)
            drawSplines()
          }

          $("canvas").onclick = e => {
            points.push(mousePositionOnCanvas(e))
            drawSplines()
          }

          const clear = canvas => {
            let ctx = canvas.getContext("2d")

            ctx.save()
            ctx.fillStyle = "rgba(255, 255, 255)"
            ctx.fillRect(0, 0, canvas.width, canvas.height)
            ctx.restore()
          }

          const mousePositionOnCanvas = e =>
            (el =>
              // If the offsetX property is unusable, the mouse click position relative to the canvas must be calculated
              // by taking the absolute screen location and progressively subtracting the offsets of all parent DOM
              // elements. Yeah, I know, pretty tedious...
              isNaN(e.offsetX)
              ? mousePositionViaElementHierarchy(e)
              : { "x" : e.offsetX * (el.width  / el.offsetWidth  || 1)
                , "y" : e.offsetY * (el.height / el.offsetHeight || 1)
                })
            (e.target)

          const mousePositionViaElementHierarchy = e => {
            let x  = e.pageX
            let y  = e.pageY
            let el = e.target

            do {
              x -= el.offsetLeft
              y -= el.offsetTop
              el = el.offsetParent
            }
            // Stop when we reach the top of the DOM hierarchy
            while (el)

            return {
              "x" : x * (el.width  / el.offsetWidth  || 1)
            , "y" : y * (el.height / el.offsetHeight || 1)
            }
          }

          // Return the distance between any two points where each point is an object having at least the properties
          // {x: <some_number>, y: <some_number>}
          const distance = (pt1, pt2) => Math.sqrt(Math.pow(pt1.x - pt2.x, 2) + Math.pow(pt1.y - pt2.y, 2))

          // Generate the two control points that lie between the three supplied plot points
          const genControlPoints = (pt1, pt2, pt3) => {
            // Vector from start point to finish point
            // This is used to determine the gradient of the lines through the control points
            let x_vec = pt3.x - pt1.x
            let y_vec = pt3.y - pt1.y

            let d01  = distance(pt1, pt2)
            let d12  = distance(pt2, pt3)
            let d012 = d01 + d12

            // Return the coordinates of the two control points between the three current points
            return [
              { "x" : pt2.x - x_vec * TENSION * d01 / d012, "y" : pt2.y - y_vec * TENSION * d01 / d012 }
            , { "x" : pt2.x + x_vec * TENSION * d12 / d012, "y" : pt2.y + y_vec * TENSION * d12 / d012 }
            ]
          }

          const drawSplines = () => {
            let canvas = $("canvas")
            let ctx    = canvas.getContext("2d")

            clear(canvas)

            // Between each triplet of plot points, there will be two invisible control points
            let cps = points.reduce(
              (acc, pt, idx, me) =>
                idx < me.length - 2
                ? acc.concat(genControlPoints(pt, me[idx + 1], me[idx + 2]))
                : acc
              , [])

            // Draw all the plot points
            points.map(pt => drawPoint(ctx, pt.x, pt.y, "black"))

            drawCurvedPath(ctx, cps, points)
          }

          const drawPoint = (ctx, x, y, fillStyle) => {
            ctx.beginPath()

            ctx.save()
            ctx.fillStyle = fillStyle
            ctx.arc(x, y, POINT_RADIUS, 0.0, TWO_PI)
            ctx.fill()
            ctx.restore()
          }

          const drawCurvedPath = (ctx, cps, points) => {
            // As long as we have at least two points...
            if (points.length >= 2) {
              // First point
              ctx.beginPath()
              ctx.moveTo(points[0].x, points[0].y)

              // Are there only 2 points?
              if (points.length == 2) {
                // Yup, so draw a line to the last point and we're done
                ctx.lineTo(points[1].x, points[1].y)
              }
              else {
                // For 3 or more points...
                // Plot points 0 and 1 are connected with a quadratic Bezier
                ctx.quadraticCurveTo(cps[0].x, cps[0].y, points[1].x, points[1].y)

                // All middle plot points are connected with a cubic Bezier that requires a pair of control points
                for (var i = 2; i < points.length-1; i++) {
                  let cp_idx1 = (i - 2) * 2 + 1
                  let cp_idx2 = (i - 1) * 2

                  ctx.bezierCurveTo(cps[cp_idx1].x, cps[cp_idx1].y, cps[cp_idx2].x, cps[cp_idx2].y, points[i].x, points[i].y)
                }

                // Last two plot points are connected with a quadratic Bezier
                ctx.quadraticCurveTo(cps[cps.length - 1].x, cps[cps.length - 1].y, points[i].x, points[i].y)
              }

              // Draw the curve
              ctx.stroke()
            }
          }
        </script>
      </body>
    </html>